---
title: "Исследование информации о состоянии беспроводных сетей"
format: 
  md:
    output-file: README.md
---

## Цель работы

1. Получить знания о методах исследования радиоэлектронной обстановки.
2. Составить представление о механизмах работы Wi-Fi сетей на канальном и
сетевом уровне модели OSI.
3. Зекрепить практические навыки использования языка программирования R для
обработки данных
4. Закрепить знания основных функций обработки данных экосистемы tidyverse
языка R

## Исходные данные

1. Rstudio Desktop
2. Наше рабочее окружение

## План

1. Импортировать данные.
2. Привести датасеты в вид “аккуратных данных”, преобразовать типы столбцов в
соответствии с типом данных
3. Просмотреть общую структуру данных с помощью функции glimpse()

## Шаги: 

```{r}
sessionInfo()
``` 
## Подготовка данных

1\. Импортировали данные.

```{r}
library(tidyverse)
```
```{r}
url <- "https://storage.yandexcloud.net/dataset.ctfsec/P2_wifi_data.csv"
```

2\. Привели датасеты в вид “аккуратных данных”, преобразовали типы столбцов в соответствии с типом данных

```{r}
raw_text <- read_file(url)
lines <- str_split(raw_text, "\n", simplify = TRUE)[1,]
client_line <- which(str_detect(lines, "Station MAC"))
if (length(client_line) > 0) {
  ap_text <- lines[1:(client_line - 2)]
  client_text <- lines[client_line:length(lines)]
  ap_raw <- read_csv(I(ap_text))
  client_raw <- read_csv(I(client_text))
}
```


```{r}
ap_tidy <- ap_raw %>%
  rename(
    beacons = `# beacons`,
    IV = `# IV`
  ) %>%
  mutate(
    `First time seen` = ymd_hms(`First time seen`),
    `Last time seen` = ymd_hms(`Last time seen`),
    channel = as.integer(channel),
    Speed = as.numeric(Speed),
    Power = as.integer(Power),
    beacons = as.integer(beacons),
    IV = as.integer(IV),
    `ID-length` = as.integer(`ID-length`)
  )
```


```{r}
client_tidy <- client_raw %>%
  rename(
    packets = `# packets`
  ) %>%
  mutate(
    `First time seen` = ymd_hms(`First time seen`),
    `Last time seen` = ymd_hms(`Last time seen`),
    Power = as.integer(Power),
    packets = as.integer(packets)
  )
```


3\. Просмотрели общую структуру данных с помощью функции glimpse()

```{r}
glimpse(ap_tidy)

```

```{r}
glimpse(client_tidy)
```

## Анализ
### Точки доступа
1\. Определили небезопасные точки доступа (без шифрования – OPN)

```{r}
ap_tidy %>%
  filter(Privacy == "OPN") %>%
  count()
```

2\. Определили производителя для каждого обнаруженного устройства

```{r}
ap_tidy <- ap_tidy %>%
  mutate(
    OUI = substr(gsub(":", "", BSSID), 1, 6)
  )
ap_tidy %>% select(BSSID, OUI, ESSID) %>% head(10)
```

3\. Выявили устройства, использующие последнюю версию протокола шифрования WPA3, и названия точек доступа, реализованных на этих устройствах

ap_tidy %>%
+     filter(Authentication == "SAE PSK" | Privacy == "WPA3 WPA2") %>%
+     distinct(ESSID) %>%
+     arrange(ESSID)  %>% print()
  ESSID                                         
1 "Christie’s"                                  
2 "iPhone (Анастасия)"                          
3 "iPhone XS Max \U0001f98a\U0001f431\U0001f98a"
4 "Димасик"                                     
5  NA   
```{r}
ap_tidy %>%
    filter(Authentication == "SAE PSK" | Privacy == "WPA3 WPA2") %>%
    distinct(ESSID) %>%
    arrange(ESSID)  %>% print()
```

4\. Отсортировали точки доступа по интервалу времени, в течение которого они находились на связи, по убыванию.

 
```{r}
ap_tidy <- ap_tidy %>%
  mutate(Connection_duration = as.numeric(difftime(`Last time seen`, 
                                                   `First time seen`, 
                                                   units = "mins")))
ap_sorted_by_time <- ap_tidy %>% arrange(desc(Connection_duration))
ap_tidy %>% arrange(desc(Connection_duration)) %>% print()
```

5\. Обнаружили топ-10 самых быстрых точек доступа.

> ap_tidy %>%
+     arrange(desc(Speed)) %>%
+     select(BSSID, ESSID, Speed) %>%
+     head(10)
   BSSID             ESSID              Speed
 1 26:20:53:0C:98:E8 NA                   866
 2 96:FF:FC:91:EF:64 NA                   866
 3 CE:48:E7:86:4E:33 iPhone (Анастасия)   866
 4 8E:1F:94:96:DA:FD iPhone (Анастасия)   866
 5 9A:75:A8:B9:04:1E KC                   360
 6 4A:EC:1E:DB:BF:95 POCO X5 Pro 5G       360
 7 56:C5:2B:9F:84:90 OnePlus 6T           360
 8 E8:28:C1:DC:B2:41 MIREA_GUESTS         360
 9 E8:28:C1:DC:B2:40 MIREA_HOTSPOT        360
10 E8:28:C1:DC:B2:42 NA                   360

6\. Отсортировали точки доступа по частоте отправки запросов (beacons) в единицу времени по их убыванию

```{r}
ap_tidy %>%
      mutate(Beacon_rate = beacons / Connection_duration) %>%
      arrange(desc(Beacon_rate)) %>%
      select(BSSID, ESSID, beacons, Connection_duration, Beacon_rate)
```
 

### Данные клиентов
1\. Определить производителя для каждого обнаруженного устройства
```{r}
top_ouis <- client_tidy %>%
  mutate(OUI = substr(gsub(":", "", `Station MAC`), 1, 6)) %>%
  count(OUI, sort = TRUE) %>%
  head(20)

top_ouis
```
```{r}
client_oui_db_large <- tribble(
  ~OUI, ~Manufacturer,
  "CA663B", "Apple",
  "96352D", "Huawei",
  "A4F1E8", "Apple",
  "C4E984", "TP-Link",
  "E828C1", "Apple",
  "D26D52", "Huawei",
  "5C3A45", "Samsung",
  "C0E434", "AzureWave",
  "68545A", "Samsung",
  "CA54C4", "Huawei",
  "4AC928", "Huawei",
  "A0E70B", "Intel",
  "009569", "NVIDIA",
  "00E93A", "HTC",
  "00F48D", "Huawei",
  "04C06F", "TP-Link",
  "080028", "Apple",
  "0C8BFD", "Intel",
  "10C07C", "Broadcom"
)
```
Объединяем с нашими данными
```{r}
client_tidy <- client_tidy %>%
  mutate(OUI = substr(gsub(":", "", `Station MAC`), 1, 6)) %>%
  left_join(client_oui_db_large, by = "OUI")
```
Проверяе что устройства получили производителя
```{r}
client_tidy %>%
  select(`Station MAC`, Manufacturer) %>%
  head(20)
```

2\. Обнаружить устройства, которые НЕ рандомизируют свой MAC адрес

```{r}
client_tidy %>%
  group_by(`Station MAC`) %>%
  summarise(
    Different_networks = n_distinct(`Probed ESSIDs`, na.rm = TRUE),
    Total_probes = n(),
    .groups = "drop") %>%
  filter(Different_networks > 1) %>%
  arrange(desc(Different_networks))
```

3\. Кластеризовать запросы от устройств к точкам доступа по их именам.
Определить время появления устройства в зоне радиовидимости и время выхода его из нее.

```{r}
client_tidy %>%
  filter(!is.na(`Probed ESSIDs`) & `Probed ESSIDs` != "") %>%
  group_by(`Station MAC`, `Probed ESSIDs`) %>%
  summarise(
    First_seen = min(`First time seen`),
    Last_seen = max(`Last time seen`),
    Duration_minutes = as.numeric(difftime(max(`Last time seen`), 
                                          min(`First time seen`), 
                                          units = "mins")),
    Avg_power = mean(Power, na.rm = TRUE),
    .groups = "drop"
  )%>%
  arrange(desc(Duration_minutes)) %>%
  head(10)
```


4\. Оценить стабильность уровня сигнала внури кластера во времени. Выявить наиболее стабильный кластер.
```{r}
stability <- client_tidy %>%
  filter(!is.na(`Probed ESSIDs`) & `Probed ESSIDs` != "") %>%
  group_by(`Station MAC`, `Probed ESSIDs`) %>%
  summarise(
    Mean_power = mean(Power, na.rm = TRUE),
    SD_power = sd(Power, na.rm = TRUE),
    Observations = n(),
    .groups = "drop"
  ) %>%
  mutate(
    Stability_index = SD_power / abs(Mean_power),  
    CV_power = (SD_power / abs(Mean_power)) * 100  
  ) %>%
  filter(!is.na(Stability_index) & is.finite(Stability_index))
stability %>%
  arrange(Stability_index) %>%
  head(1)

```

