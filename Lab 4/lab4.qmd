---
title: "Основы обработки данных с помощью R и Dplyr"
format: 
  md:
    output-file: README.md
---

## Цель работы

1. Зекрепить практические навыки использования языка программирования R для
обработки данных
2. Закрепить знания основных функций обработки данных экосистемы tidyverse
языка R
3. Закрепить навыки исследования метаданных DNS трафика

## Исходные данные

1. Rstudio Desktop
2. Наше рабочее окружение
       
## План

1. Импортировать данные DNS –
https://storage.yandexcloud.net/dataset.ctfsec/dns.zip
2. Добавить пропущенные данные о структуре данных (назначении столбцов)
3. Преобразовать данные в столбцах в нужный формат
4. Просмотреть общую структуру данных с помощью функции glimpse()
5. Ответить на вопросы

## Шаги: 

```{r}
sessionInfo()
``` 
1. Импортировать данные DNS –
https://storage.yandexcloud.net/dataset.ctfsec/dns.zip

```{r}
 url <- "https://storage.yandexcloud.net/dataset.ctfsec/dns.zip"
 download.file(url, "dns.zip")
 unzip("dns.zip")
 dns_data <- read.csv("dns.log", sep = "\t", header = FALSE)
```

2. Добавить пропущенные данные о структуре данных (назначении столбцов)

```{r}
zeek_dns_columns <- c(
    "ts", "uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p",
    "proto", "trans_id", "query", "qclass", "qclass_name", "qtype",
    "qtype_name", "rcode", "rcode_name", "AA", "TC", "RD", "RA",
    "Z", "answers", "TTLs", "rejected"
)
colnames(dns_data) <- zeek_dns_columns
```

3\. Преобразовать данные в столбцах в нужный формат

```{r}
library(dplyr)
dns_data <- dns_data %>% 
  mutate(ts = as.POSIXct(ts, origin = "1970-01-01"),
    id.orig_p = as.integer(id.orig_p),
    id.resp_p = as.integer(id.resp_p),
    trans_id = as.integer(trans_id),
    qclass = as.integer(qclass),
    qtype = as.integer(qtype),
    rcode = as.integer(rcode),
    Z = as.integer(Z)
  )
```

4\. Просмотреть общую структуру данных с помощью функции glimpse()

```{r}
glimpse(dns_data)
```

5\. Сколько участников информационного обмена в сети Доброй Организации?
 
```{r}
all_ips <- unique(c(dns_data$id.orig_h, dns_data$id.resp_h))
length(all_ips)
```

6\. Какое соотношение участников обмена внутри сети и участников обращений к внешним ресурсам?

```{r}
internal_ips <- all_ips[grepl("^192\\.168\\.", all_ips)]
external_ips <- setdiff(all_ips, internal_ips)
r <- length(internal_ips) / length(external_ips)
r
```

7\. Найдите топ-10 участников сети, проявляющих наибольшую сетевую активность.

```{r}
dns_data %>% 
  count(id.orig_h) %>% 
  arrange(desc(n)) %>% 
  head(10)
```

8\. Найдите топ-10 доменов, к которым обращаются пользователи сети и соответственное количество обращений.

``` {r}
dns_data %>% count(query) %>% arrange(desc(n)) %>% head(10)
```                                                         

9\. Опеределите базовые статистические характеристики (функция summary() ) интервала времени между последовательными обращениями к топ-10 доменам.

```{r}
top_10_domains <- dns_data %>% count(query) %>% arrange(desc(n)) %>% head(10) %>% pull(query)
top_times <- dns_data %>% filter(query %in% top_10_domains) %>% pull(ts) %>% sort()
```

10\. Часто вредоносное программное обеспечение использует DNS канал в качестве канала управления, периодически отправляя запросы на подконтрольный злоумышленникам DNS сервер. По периодическим запросам на один и тот же домен можно выявить скрытый DNS канал. Есть ли такие IP адреса в исследуемом датасете?

```{r}
top_repeaters <- dns_data %>% count(id.orig_h, query) %>% filter(n > 50) %>% arrange(desc(n))
head(top_repeaters, 20)
```

11\. Определите местоположение (страну, город) и организацию-провайдера для топ-10 доменов. Для этого можно использовать сторонние сервисы, например http://ip-api.com (API-эндпоинт http://ip-api.com/json).

```{r}
library(httr)
library(purrr)

top_10_dom <- dns_data |> 
  count(query, sort = TRUE) |> 
  head(10) |> 
  pull(query)

get_geo <- function(domain) {
  tryCatch({
    ip <- try(nslookup(domain, server="8.8.8.8"), silent=TRUE)
    
    if(inherits(ip, "try-error") || is.null(ip)) {
      return(data.frame(
        domain = domain,
        ip = NA,
        country = NA,
        city = NA,
        isp = NA
      ))
    }
    
    response <- GET(paste0("http://ip-api.com/json/", ip[[1]]))
    data <- content(response, "parsed")
    
    if(data$status == "success") {
      data.frame(
        domain = domain,
        ip = data$query,
        country = data$country,
        city = data$city,
        isp = data$isp
      )
    } else {
      data.frame(
        domain = domain,
        ip = ip[[1]],
        country = NA,
        city = NA,
        isp = NA
      )
    }
  }, error = function(e) {
    data.frame(
      domain = domain,
      ip = NA,
      country = NA,
      city = NA,
      isp = NA
    )
  })
}

results <- map_dfr(top_10_dom, get_geo)
results
```

